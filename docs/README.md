# 구현할 기능 목록

> 유효값을 확인하는 부분 중 중복 서술되는 부분이 많아 따로 분리하였습니다. **Bold**처리 된 글자를 사용하여 기능 목록에서 수행할 유효값 체크를 적었습니다.

## 기능 목록

- [x] 출력을 통해 사용자에게 입력값을 안내한다.
- [ ] 출력을 통해 입력값을 바탕으로 도출값을 안내한다.
- [ ] 로또 구입 금액을 입력받는다.
  - [ ] 입력받은 로또 구입 금액값이 올바른지 확인한다(정수, 1000).
- [ ] 로또 구매 갯수만큼 로또를 구매한다.
  - [ ] `Randoms`의 `pickUniqueNumbersInRange()`를 활용해 1부터 45의 번호 6개를 뽑아 로또 번호로 지정한다.
  - [ ] 구매한 로또 번호들을 오름차순으로 정렬한다.
- [ ] 당첨 번호를 입력받는다.
  - [ ] 입력받은 당첨 번호들이 올바른지 확인한다(쉼표, 정수, 로또의 범위, 중복값).
- [ ] 보너스 번호를 입력받는다.
  - [ ] 입력받은 보너스 번호가 올바른지 확인한다(정수, 당첨 번호에 포함).
- [ ] 당첨 통계를 계산한다.
  - [ ] 구매한 로또 하나씩 당첨번호와 일치한 값의 갯수를 확인한다.
    - [ ] 일치하는 번호가 5개일 경우, 보너스 볼이 일치하는지 확인한다.
- [ ] 당첨 통계를 출력한다.
- [ ] 수익률(당첨금액 / 구입금액)을 계산한다.
  - [ ] 당첨 통계를 바탕으로 당첨금액을 계산한다.
- [ ] 수익률을 출력한다.

## 유효값 체크(`IllegalArgumentException`)

- [x] **정수**로 변환할 수 없는 경우
- [ ] **1000**으로 나누어 떨어지지 않는 경우
- [ ] **쉼표**를 기준으로 값을 나누었을 때 6개가 아닌 경우
- [ ] **로또의 범위**(1~45)를 벗어난 경우
- [ ] **중복값**이 있을 경우
- [ ] 보너스 번호가 **당첨 번호에 포함**될 경우



# 초기 구현

## 구현 전 클래스 지정

> 구현할 기능 목록들에 따른 각자의 역할을 생각하고 구현할 클래스를 나눠보았다.

### 로또샵 클래스

로또를 구매하고 확인하는 전반적인 진행 담당

### 메시지 출력 클래스

구입 금액 입력 요구, 로또 갯수, 로또 번호 출력 등의 기능을 담당

### 메시지 입력 클래스

사용자가 입력한 메시지를 올바른 자료구조로 변형

### 유효값 체크 클래스

입력받은 값이 올바른지 확인

### 로또번호 클래스(문제에서 주어진 Lotto 클래스 이용)

`Randoms.pickUniqueNumbersInRange()`를 통해 생성된 로또 번호로 생성

### 당첨번호 클래스

사용자의 입력을 통해 당첨 번호와 보너스 번호를 지정

### 통계 클래스

로또번호 클래스와 당첨번호 클래스를 비교하며, 당첨 통계를 작성

### 계산 클래스

당첨 통계를 바탕으로 당첨금액과 수익률을 계산

## 구현

- 시작하자마자 출력 클래스에 대한 고민이 생겼다.
  - 출력할 내용은 크게 7가지(구입금액 입력 요구, 구매갯수 확인, 구매한 로또 번호들, 당첨번호 입력 요구, 보너스번호 입력 요구, 당첨 통계, 수익률)이다.
    - 구입금액 입력 요구, 당첨번호 입력 요구, 보너스번호 입력 요구는 지정된 텍스트를 출력한다.
    - 나머지 항목들은 지정된 텍스트 + @를 출력한다.
  - 그렇다면 해당 클래스는 `지정된 텍스트 출력`, `지정된 텍스트 + @ 출력`으로 나눌 수 있다.
  - 지정된 텍스트들은 바뀔 일이 없으며, 이는 enum 클래스로 선언하는 게 나을 것 같았다.
    - 2주차 때 우연치않게 enum에 대해 공부하게 되었는데(3주차에서 나올 줄 몰랐어요.. 정말로!), 덕분에 생각의 흐름을 쉽게 가져갈 수 있던 것 같다.
  - 출력 클래스 자체를 enum으로 해보고 싶었으나, 텍스트 + @에 대한 다형성을 어떻게 구현해야 할 지 막막했다. 따라서 리팩터링 때 생각해보기로 했다.
- 유효값 체크 클래스의 출력 텍스트 또한 enum으로 선언할 수 있다고 생각되었다.
  - `입력값이 null입니다.` 등의 텍스트도 지정된 텍스트이므로, 해당 값들도 enum으로 선언할 수 있을 것 같았다.
  - 다만, 출력 클래스에서 지정한 값들과는 별개로 관리해야 한다고 생각되었다. 둘 다 같은 형태이긴 하겠지만, 사용되는 목적이 다르니 `LottoText`와 `ExceptionText`로 작성하면 좋을 것 같았다.
  - 그렇다면 Text라는 기본 클래스를 만들고, 위의 두 enum 클래스에서 상속하면 편하겠다!
  - 헌데 enum 클래스는 상속이 불가했다. 함축적으로 enum 객체를 상속받고 있기 때문이라 한다. 따라서 그냥 같은 형태로만 만들어주었다.
  - 대신 직접 내용에 해당하는 `IllegalArgumentException`을 던질 수 있도록 작성했다. 어라.. 이러면 `ExceptionText`로 작성하면 안되는데..?
  - 유효값이 아닐 경우를 모아두는 거니까.. 간단하게 `Invalid`로 하기로 했다.

## 고민한 사항

- 테스트코드를 위한 메서드를 main에 작성하는 게 옳은 걸까?
  - NULL 테스트를 위해 코드를 작성했다. 이 때, 해당 메시지가 `입력값은 null일 수 없습니다.`가 나오는지 정확히 파악하려면, 그리고 해당 메시지가 변경되어도 검증할 수 있으려면 `Invalid.content`를 얻어와야 한다.
  - 그러나 main 내에서는 `Invalid.content`를 얻어올 일이 없으며, 테스트코드를 위한 메서드를 작성하게 될 것 같았다.
  - 그렇게 좋은 방법은 아닌 것 같아 에러메시지 내부에서 `null`을 포함하는지만 검사하기로 했다. 극단적으로 갔을 때, 테스트코드가 주가 되어버리는 게 생길.. 어? TDD에선 그런 식으로 하지 않을까..?
  - 고민을 계속 하다가, 결국 `Invalid`의 `toString()`에서 `content`를 반환하는 식으로 오버라이드하였다. 따라서 내부 코드도 조금 단순하게 가져가고, 테스트코드에서도 제대로 비교할 수 있도록 해 보았다.
  - 하지만 본질적인 의구심은 해결하지 못 했다.. 확장적인 코드를 작성하여 main과 test를 둘 다 신경쓰는 방식을 도입하는 게 제일 나은 것 같아서 해당 방법을 구상하였으나, 실제 TDD를 작업할 때는 어떠한 방식을 선택할까?
  - `비즈니스 로직과 완전히 상관없는, 테스트만을 위한 메서드는 필요하지 않다`라는 답변을 얻었다. 물론 사람마다 다르다곤  하지만.. 나도 여기에 동의하는 바이다.
  - 또한 테스트코드에서는 에러메시지를 하드코딩하고 비교하는 방법이 쓰이는 것 같다. 잘못된 에러메시지를 가져오면 바로 알 수 있게끔.. 헌데 내 구조는 에러메시지가 변화되지 않는 형태이고, 검증 메서드에 값을 던졌을 때 해당 에러가 제대로 발생하는지 확인하는 형태이기 때문에.. 이부분은 조금 더 생각해봐야 할 것 같다.
- 20억을 초과한 값
  - 1등보다 많은 값만큼 로또를 살 사람은 없다고 생각.. 했으나, 시뮬레이션이기 때문에 있을 수도 있다고 판단되었다..
  - 헌데 값을 Int형으로 제한할 경우, 21억이 넘어가면 에러가 터진다.
  - 그렇다고 Long을 쓰자니, 로또 용지를 어마어마하게 발급해줘야 한다..
  - ![image-20221110150724621](README.assets/image-20221110150724621.png)
  - 아.. 판매량에는 제한이 없구나.. 그럼 어마어마하게 발급해주는 것도 있을 수 있겠구나..
  - 가게마다의 제한은 있을 수 있겠지만.. 적어도 21억 이상으로 시뮬레이션을 돌리고 싶은 사람은 있을 수 있겠다 싶었다.
  - 근데 21억정도만 사도 210만개의 출력이 콘솔에 찍히는데, 그 이상으로 받아들인다면 좀 무리이지 않을까?
  - 제한 사항은 내가 설정하는거니, 가게 사정상 Int형의 범위를 벗어나는건 안된다고 설정하고 진행해야겠다 싶었다. Long을 하고 싶긴 하지만.. 그에 따를 나비효과가 좀 무서웠다 ㅠ
- 값 확인보다 차라리 숫자로 바꿔보며 나오는 에러를 처리하는게 낫지 않을까?
  - null, 문자열, 정수값을 넘은 경우 모두 `NumberFormatException`을 발생시킨다.
  - 굳이 내가 확인처리를 하지 않고, `Integer.parseToInt`에게 할 일을 맡긴 뒤 나오는 에러를 처리해주는게 더 효율적이지 않을까?
    - 0 이하의 값인지만 더 확인해주면, 따로 건드릴 일이 없을 것 같았다.
    - 더 이해하기 쉽고, 확실한 처리 능력일 듯 했다.
  - 따라서 null이 입력된 경우, 숫자가 입력되지 않은 경우, 정수값의 범위를 넘은 경우에 대한 사항들을 모두 `Integer`에게 맡기기로 했다.
  - 헌데 이렇게 되니, `Validate`가 해당 과정을 지녀야 할 지 의심되었다. 미리 확인하는 것과 변형하며 나오는 에러를 도출해주는 건 다르지 않나 싶었다..
  - 따라서 네이밍을 `Convert`로 지어주고, 해당 전환과정 중 혹시 모를 에러를 살펴본다는 식으로 구성하기로 하려 했다. 그러나 이미 Invalid가 에러메시지를 넘겨주는 녀석이니, 이 녀석을 잘 작성하여 다형성까지 구현해주고 싶은 마음이 생겼다.
  - 구글링으로 [인터페이스를 구현한 Enum 클래스](https://vvshinevv.tistory.com/78)를 확인하였고, 해당 방법을 사용해보기로 했다. 그러나.. 애초에 enum은 같은 형태를 지닌 녀석들을 나열하기 위함이고, enum 객체 하나마다 파라미터를 달리 받아 도출해내는 건 class에서의 역할로 보였다. 에러메시지는 여러 파라미터 타입을 받으며 때에 따라 동작해야 하고, 이를 모두 enum으로 퉁치려는 건 위험해 보였다.
  - 억지로 구현해보려고도 했으나.. 해당 블로그 글에 [특별히 Generic Parameterized Type에 제한](https://vvshinevv.tistory.com/56)을 두지 않으면' 가능하다는 듯 보였다. 나는 파라미터를 하나씩 세팅하려 했으니..
  - 물론 방법이 있을 지도 모른다. 하지만 몇 시간 째 이것만 붙잡고 있느라 다른 것들을 제대로 구현하지도 못 한 상황이니, 나중에 더 공부하기로 하고 우선은 `Convert` 내부를 완성시키기로 했다.

