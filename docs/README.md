# 구현할 기능 목록

> 유효값을 확인하는 부분 중 중복 서술되는 부분이 많아 따로 분리하였습니다. **Bold**처리 된 글자를 사용하여 기능 목록에서 수행할 유효값 체크를 적었습니다.

## 기능 목록

- [x] 출력을 통해 사용자에게 입력값을 안내한다.
- [x] 출력을 통해 입력값을 바탕으로 도출값을 안내한다.
- [x] 로또 구입 금액을 입력받는다.
  - [x] 입력받은 로또 구입 금액을 정수로 전환한다.

- [x] 로또 구매 갯수만큼 로또를 구매한다.
  - [x] 입력받은 로또 구입 금액값이 올바른지 확인한다(**1000**).
  - [x] `Randoms`의 `pickUniqueNumbersInRange()`를 활용해 1부터 45의 번호 6개를 오름차순으로 뽑아 로또 번호로 지정한다.
  - [x] 로또 번호들을 출력한다.

- [x] 당첨 번호를 입력받는다.
  - [x] 입력받은 당첨 번호들을 정수로 전환한다.
    - [x] 입력받은 당첨 번호들이 올바른지 확인한다(**쉼표, 로또의 범위, 중복값**).

- [x] 보너스 번호를 입력받는다.
  - [x] 입력받은 보너스 번호를 정수로 전환한다.
    - [x] 입력받은 보너스 번호가 올바른지 확인한다(**로또의 범위**).

- [x] 로또 당첨 번호 객체를 생성한다.
  - [x] 입력받은 당첨 번호들과 보너스 번호가 올바른지 확인한다(**당첨 번호에 포함**).

- [ ] 당첨 통계를 계산한다.
  - [ ] 구매한 로또 하나씩 당첨번호와 일치한 값의 갯수를 확인한다.
    - [ ] 일치하는 번호가 5개일 경우, 보너스 볼이 일치하는지 확인한다.
- [ ] 당첨 통계를 출력한다.
- [ ] 수익률(당첨금액 / 구입금액)을 계산한다.
  - [ ] 당첨 통계를 바탕으로 당첨금액을 계산한다.
- [ ] 수익률을 출력한다.

## 유효값 체크(`IllegalArgumentException`)

- [x] **정수**로 변환할 수 없는 경우
- [x] **1000**으로 나누어 떨어지지 않는 경우
- [x] **쉼표**를 기준으로 값을 나누었을 때 6개가 아닌 경우
- [x] **로또의 범위**(1~45)를 벗어난 경우
- [x] **중복값**이 있을 경우
- [x] 보너스 번호가 **당첨 번호에 포함**될 경우



# 초기 구현

## 구현 전 클래스 지정

> 구현할 기능 목록들에 따른 각자의 역할을 생각하고 구현할 클래스를 나눠보았다.

### 로또샵 클래스

로또를 구매하고 확인하는 전반적인 진행 담당

### 메시지 출력 클래스

구입 금액 입력 요구, 로또 갯수, 로또 번호 출력 등의 기능을 담당

### 메시지 입력 클래스

사용자가 입력한 메시지를 올바른 자료구조로 변형

### 유효값 체크 클래스

입력받은 값이 올바른지 확인

### 로또번호 클래스(문제에서 주어진 Lotto 클래스 이용)

`Randoms.pickUniqueNumbersInRange()`를 통해 생성된 로또 번호로 생성

### 당첨번호 클래스

사용자의 입력을 통해 당첨 번호와 보너스 번호를 지정

### 통계 클래스

로또번호 클래스와 당첨번호 클래스를 비교하며, 당첨 통계를 작성

### 계산 클래스

당첨 통계를 바탕으로 당첨금액과 수익률을 계산

## 고민한 사항

- 시작하자마자 출력 클래스에 대한 고민이 생겼다.
  - 출력할 내용은 크게 7가지(구입금액 입력 요구, 구매갯수 확인, 구매한 로또 번호들, 당첨번호 입력 요구, 보너스번호 입력 요구, 당첨 통계, 수익률)이다.
    - 구입금액 입력 요구, 당첨번호 입력 요구, 보너스번호 입력 요구는 지정된 텍스트를 출력한다.
    - 나머지 항목들은 지정된 텍스트 + @를 출력한다.
  - 그렇다면 해당 클래스는 `지정된 텍스트 출력`, `지정된 텍스트 + @ 출력`으로 나눌 수 있다.
  - 지정된 텍스트들은 바뀔 일이 없으며, 이는 enum 클래스로 선언하는 게 나을 것 같았다.
    - 2주차 때 우연치않게 enum에 대해 공부하게 되었는데(3주차에서 나올 줄 몰랐어요.. 정말로!), 덕분에 생각의 흐름을 쉽게 가져갈 수 있던 것 같다.
  - 출력 클래스 자체를 enum으로 해보고 싶었으나, 텍스트 + @에 대한 다형성을 어떻게 구현해야 할 지 막막했다. 따라서 리팩터링 때 생각해보기로 했다.

- 유효값 체크 클래스의 출력 텍스트 또한 enum으로 선언할 수 있다고 생각되었다.
  - `입력값이 null입니다.` 등의 텍스트도 지정된 텍스트이므로, 해당 값들도 enum으로 선언할 수 있을 것 같았다.
  - 다만, 출력 클래스에서 지정한 값들과는 별개로 관리해야 한다고 생각되었다. 둘 다 같은 형태이긴 하겠지만, 사용되는 목적이 다르니 `LottoText`와 `ExceptionText`로 작성하면 좋을 것 같았다.
  - 그렇다면 Text라는 기본 클래스를 만들고, 위의 두 enum 클래스에서 상속하면 편하겠다!
  - 헌데 enum 클래스는 상속이 불가했다. 함축적으로 enum 객체를 상속받고 있기 때문이라 한다. 따라서 그냥 같은 형태로만 만들어주었다.
  - 대신 직접 내용에 해당하는 `IllegalArgumentException`을 던질 수 있도록 작성했다. 어라.. 이러면 `ExceptionText`로 작성하면 안되는데..?
  - 유효값이 아닐 경우를 모아두는 거니까.. 간단하게 `Invalid`로 하기로 했다.

- 테스트코드를 위한 메서드를 main에 작성하는 게 옳은 걸까?
  - NULL 테스트를 위해 코드를 작성했다. 이 때, 해당 메시지가 `입력값은 null일 수 없습니다.`가 나오는지 정확히 파악하려면, 그리고 해당 메시지가 변경되어도 검증할 수 있으려면 `Invalid.content`를 얻어와야 한다.
  - 그러나 main 내에서는 `Invalid.content`를 얻어올 일이 없으며, 테스트코드를 위한 메서드를 작성하게 될 것 같았다.
  - 그렇게 좋은 방법은 아닌 것 같아 에러메시지 내부에서 `null`을 포함하는지만 검사하기로 했다. 극단적으로 갔을 때, 테스트코드가 주가 되어버리는 게 생길.. 어? TDD에선 그런 식으로 하지 않을까..?
  - 고민을 계속 하다가, 결국 `Invalid`의 `toString()`에서 `content`를 반환하는 식으로 오버라이드하였다. 따라서 내부 코드도 조금 단순하게 가져가고, 테스트코드에서도 제대로 비교할 수 있도록 해 보았다.
  - 하지만 본질적인 의구심은 해결하지 못 했다.. 확장적인 코드를 작성하여 main과 test를 둘 다 신경쓰는 방식을 도입하는 게 제일 나은 것 같아서 해당 방법을 구상하였으나, 실제 TDD를 작업할 때는 어떠한 방식을 선택할까?
  - `비즈니스 로직과 완전히 상관없는, 테스트만을 위한 메서드는 필요하지 않다`라는 답변을 얻었다. 물론 사람마다 다르다곤  하지만.. 나도 여기에 동의하는 바이다.
  - 또한 테스트코드에서는 에러메시지를 하드코딩하고 비교하는 방법이 쓰이는 것 같다. 잘못된 에러메시지를 가져오면 바로 알 수 있게끔.. 헌데 내 구조는 에러메시지가 변화되지 않는 형태이고, 검증 메서드에 값을 던졌을 때 해당 에러가 제대로 발생하는지 확인하는 형태이기 때문에.. 이부분은 조금 더 생각해봐야 할 것 같다.

- 20억을 초과한 값
  - 1등보다 많은 값만큼 로또를 살 사람은 없다고 생각.. 했으나, 시뮬레이션이기 때문에 있을 수도 있다고 판단되었다..
  - 헌데 값을 Int형으로 제한할 경우, 21억이 넘어가면 에러가 터진다.
  - 그렇다고 Long을 쓰자니, 로또 용지를 어마어마하게 발급해줘야 한다..
  - ![image-20221110150724621](README.assets/image-20221110150724621.png)
  - 아.. 판매량에는 제한이 없구나.. 그럼 어마어마하게 발급해주는 것도 있을 수 있겠구나..
  - 가게마다의 제한은 있을 수 있겠지만.. 적어도 21억 이상으로 시뮬레이션을 돌리고 싶은 사람은 있을 수 있겠다 싶었다.
  - 근데 21억정도만 사도 210만개의 출력이 콘솔에 찍히는데, 그 이상으로 받아들인다면 좀 무리이지 않을까?
  - 제한 사항은 내가 설정하는거니, 가게 사정상 Int형의 범위를 벗어나는건 안된다고 설정하고 진행해야겠다 싶었다. Long을 하고 싶긴 하지만.. 그에 따를 나비효과가 좀 무서웠다 ㅠ

- 값 확인보다 차라리 숫자로 바꿔보며 나오는 에러를 처리하는게 낫지 않을까?
  - null, 문자열, 정수값을 넘은 경우 모두 `NumberFormatException`을 발생시킨다.
  - 굳이 내가 확인처리를 하지 않고, `Integer.parseToInt`에게 할 일을 맡긴 뒤 나오는 에러를 처리해주는게 더 효율적이지 않을까?
    - 0 이하의 값인지만 더 확인해주면, 따로 건드릴 일이 없을 것 같았다.
    - 더 이해하기 쉽고, 확실한 처리 능력일 듯 했다.
  - 따라서 null이 입력된 경우, 숫자가 입력되지 않은 경우, 정수값의 범위를 넘은 경우에 대한 사항들을 모두 `Integer`에게 맡기기로 했다.
  - 헌데 이렇게 되니, `Validate`가 해당 과정을 지녀야 할 지 의심되었다. 미리 확인하는 것과 변형하며 나오는 에러를 도출해주는 건 다르지 않나 싶었다..
  - 따라서 네이밍을 `Convert`로 지어주고, 해당 전환과정 중 혹시 모를 에러를 살펴본다는 식으로 구성하기로 하려 했다. 그러나 이미 Invalid가 에러메시지를 넘겨주는 녀석이니, 이 녀석을 잘 작성하여 다형성까지 구현해주고 싶은 마음이 생겼다.
  - 구글링으로 [인터페이스를 구현한 Enum 클래스](https://vvshinevv.tistory.com/78)를 확인하였고, 해당 방법을 사용해보기로 했다. 그러나.. 애초에 enum은 같은 형태를 지닌 녀석들을 나열하기 위함이고, enum 객체 하나마다 파라미터를 달리 받아 도출해내는 건 class에서의 역할로 보였다. 에러메시지는 여러 파라미터 타입을 받으며 때에 따라 동작해야 하고, 이를 모두 enum으로 퉁치려는 건 위험해 보였다.
  - 억지로 구현해보려고도 했으나.. 해당 블로그 글에 '[특별히 Generic Parameterized Type에 제한](https://vvshinevv.tistory.com/56)을 두지 않으면' 가능하다는 듯 보였다. 나는 파라미터를 하나씩 세팅하려 했으니.. 해당 조건에 맞지 않았다.
  - 물론 방법이 있을 지도 모른다. 하지만 몇 시간 째 이것만 붙잡고 있느라 다른 것들을 제대로 구현하지도 못 한 상황이니, 나중에 더 공부하기로 하고 우선은 `Convert` 내부를 완성시키기로 했다.
  - 헌데 또 마음에 들지 않았다. `Convert` 자체에서 유효값을 확인하게 되면, 다른 클래스에서 유효값을 검사하게 될 시 코드 중복이 생길 수 있었다. 그렇다면 `Validate` 클래스가 따로 구분이 되어야 했다.
  - `Validate` 클래스가 검사하던 도중 에러가 발생하면 `Invalid` enum 클래스를 사용해 예외를 발생시킨다. 헌데 `Invalid`는 어디서나 접근할 수 있었고, `Validate`의 역할을 다른 곳에서 대신할 수도 있었다.
  - 따라서 `Invalid` 자체를 `Validate` 안에 작성해서 사용하던가, 아니면 `Validate`가 에러를 발생시키는 부분을 제거하거나, `Validate` 자체에서 여러 파라미터에 대응하여 에러를 판단해야 했다.
  - 마지막 방법은 지금까지 계속 실패한 방법이고, 첫번째나 두번째를 사용해야 했다.
  - 근데, 굳이 에러 관련 텍스트를 enum으로 지정해야 할 필요가 있을까? 지난주 프로젝트를 진행하며, enum의 목적은 전역 상수를 편하게 관리할 수 있는 방법이었다. 하지만 에러에 대한 설명은 재활용되지도 않고, 오히려 `Validate`의 책임을 뺏어가며 다른 곳에서의 접근을 허용하는 형태였다.
  - 따라서 enum을 해제하고, 텍스트 자체를 `Validate`에서 사용하기로 했다.

- 그렇다면 다시 돌아와서, `Integer.parseToInt`를 실행하다 에러가 발생했을 시 어떻게 처리해야 하는가?
  - `Convert`는 값의 전환만 책임진다.
  - `Validate`는 값의 확인을 책임진다.
  - 값을 전환하다 에러가 나는 경우는, 결론적으로 `Convert`의 책임이 있다.
  - `Convert`는 값을 전환하다 생기는 에러를 책임질 의무가 있다.
  - 즉 `Validate`는 문제의 조건에 대한 확인을, `Convert`는 값의 전환을 책임진다고 하면 `Convert`에서 Exception 처리는 자연스러울 수 있다.
  - `throw new IllegalArgumentException`을 `Validate`에서만 처리하는 건 오히려 각각 클래스의 책임을 회피하는 것과 같다. 각 클래스는 자신의 메서드를 실행시키는 도중 나오는 예외를 스스로 처리해야 할 것이며, `Validate`는 단지 조건에 맞지 않으면 `IllegalArgumentException`을 던지는 것일 뿐, 모든 예외를 맡을 이유는 없다.

# 느낀 점

- 앞선 2주간 프리코스를 진행할 때 전체적인 코드 구조를 후딱 작성하고 리팩터링하곤 했다.
- 이번주는 처음부터 코드 방향성에 대해 고민을 하고, 메서드별로 클래스를 부여하고, 단위테스트 코드를 작성하는 식으로 조금씩 천천히 쌓아나갔다.
- 생각보다 힘들고 오래 걸렸다.. 하루 종일 했는데도 구현 목록의 절반 정도밖에 작성하지 못 했다. 아직 익숙해지지 않아서 그런 것 같다.
- 그래도 뭔가 뿌듯하다. 처음 프로그래밍을 배울 때의 그 느낌이 나는 듯 하다. 차근차근 설명서대로 레고를 짜맞추는 기분? 마구 덩어리째 집어서 턱 턱 올려놓는 느낌이 아니라 재미있다.
- 근데 이걸 어떻게 MVC 패턴으로 옮기지..? 싶다. 매 주마다 다른 분들의 리뷰를 구경하며 하나씩 아이템을 잡았는데, 지난주에는 MVC 패턴을 사용한 분들이 꽤 있어서 도전해보기로 했다. 특히 코드 구성을 많이 배우려고 깃헙 팔로우한 분도 있는데, 그 분도 MVC를 쓰셨더라..
- 코수타에서는 `주어진 걸 열심히 하라`고 했다. MVC를 사용하기 전에 장점에 대해 충분히 이해하고, 정말 좋은 형태구나 싶어 욕심이 생기면서도 리팩터링할 시간이 남으면 시도해봐야겠다.
